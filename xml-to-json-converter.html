<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AIRAYA XML to JSON Converter</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
      border-radius: 12px 12px 0 0;
    }

    .header h1 {
      font-size: 2rem;
      margin-bottom: 5px;
    }

    .toolbar {
      background: #f8f9fa;
      padding: 20px;
      border-bottom: 2px solid #e5e7eb;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary { background: #667eea; color: white; }
    .btn-primary:hover { background: #5568d3; }
    .btn-success { background: #10b981; color: white; }
    .btn-success:hover { background: #059669; }
    .btn-secondary { background: #6b7280; color: white; }
    .btn-secondary:hover { background: #4b5563; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .content {
      padding: 30px;
    }

    .converter-layout {
      display: grid;
      grid-template-columns: 1fr 80px 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .editor-panel {
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 500px;
    }

    .panel-header {
      background: #f9fafb;
      padding: 15px;
      border-bottom: 2px solid #e5e7eb;
      font-weight: 600;
      color: #374151;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .tabs-container {
      display: flex;
      background: #f9fafb;
      border-bottom: 2px solid #e5e7eb;
      overflow-x: auto;
      flex-shrink: 0;
    }

    .tab {
      padding: 10px 20px;
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      color: #6b7280;
      border-bottom: 3px solid transparent;
      white-space: nowrap;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tab:hover {
      background: #f3f4f6;
      color: #374151;
    }

    .tab.active {
      color: #667eea;
      border-bottom-color: #667eea;
      background: white;
    }

    .tab-close {
      margin-left: 5px;
      color: #9ca3af;
      font-weight: bold;
      font-size: 1.1rem;
    }

    .tab-close:hover {
      color: #ef4444;
    }

    .json-highlight {
      background: #fef3c7 !important;
      animation: fadeHighlight 3s ease-out;
    }

    @keyframes fadeHighlight {
      0% { background: #fef3c7; }
      100% { background: transparent; }
    }

    .json-diff-line {
      background: #d1fae5;
      border-left: 3px solid #10b981;
      display: block;
      margin: 0 -20px;
      padding: 0 20px;
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    .panel-content {
      padding: 0;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    textarea {
      width: 100%;
      height: 100%;
      padding: 20px;
      border: none;
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      resize: none;
      background: #ffffff;
      color: #1f2937;
      transition: background 0.3s, color 0.3s;
    }

    textarea.dark-theme {
      background: #1f2937;
      color: #10b981;
    }

    textarea:focus {
      outline: none;
    }

    .theme-toggle {
      display: flex;
      gap: 5px;
      align-items: center;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      padding: 5px;
    }

    .theme-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      background: transparent;
      color: #6b7280;
    }

    .theme-btn.active {
      background: #667eea;
      color: white;
    }

    .theme-btn:hover {
      background: #f3f4f6;
    }

    .theme-btn.active:hover {
      background: #5568d3;
    }

    .convert-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      color: #667eea;
      padding-top: 50px;
    }

    .alert {
      padding: 15px;
      border-radius: 6px;
      margin-bottom: 20px;
      font-weight: 500;
      max-height: 400px;
      overflow-y: auto;
    }

    .alert-success {
      background: #d1fae5;
      color: #065f46;
      border-left: 4px solid #10b981;
    }

    .alert-error {
      background: #fee2e2;
      color: #991b1b;
      border-left: 4px solid #ef4444;
    }

    .alert-info {
      background: #dbeafe;
      color: #1e40af;
      border-left: 4px solid #3b82f6;
    }

    .stats-bar {
      background: #f9fafb;
      padding: 15px 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      display: flex;
      justify-content: space-around;
      border: 2px solid #e5e7eb;
      flex-wrap: wrap;
      gap: 15px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-item .label {
      font-size: 0.75rem;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }

    .stat-item .value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #667eea;
      margin-top: 3px;
    }

    .batch-section {
      background: #f9fafb;
      padding: 20px;
      border-radius: 8px;
      border: 2px solid #e5e7eb;
      margin-top: 30px;
    }

    .batch-header {
      font-size: 1.2rem;
      font-weight: 700;
      color: #374151;
      margin-bottom: 15px;
    }

    .file-list {
      max-height: 200px;
      overflow-y: auto;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 10px;
      margin: 15px 0;
    }

    .file-item {
      padding: 8px;
      border-bottom: 1px solid #f3f4f6;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .file-item:last-child {
      border-bottom: none;
    }

    .file-status {
      font-size: 0.85rem;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
    }

    .status-pending { background: #fef3c7; color: #92400e; }
    .status-success { background: #d1fae5; color: #065f46; }
    .status-error { background: #fee2e2; color: #991b1b; }

    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 220px;
      background-color: #1f2937;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1000;
      bottom: 125%;
      left: 50%;
      margin-left: -110px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #1f2937 transparent transparent transparent;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin: 15px 0;
    }

    .progress-fill {
      height: 100%;
      background: #10b981;
      width: 0%;
      transition: width 0.3s;
    }

    @media (max-width: 968px) {
      .converter-layout {
        grid-template-columns: 1fr;
      }
      .convert-arrow {
        transform: rotate(90deg);
        padding: 20px 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üîÑ AIRAYA XML to JSON Converter</h1>
      <p>Simple, Fast, Batch Conversion</p>
    </div>

    <div class="toolbar">
      <div class="tooltip">
        <button class="btn btn-primary" onclick="document.getElementById('singleFileInput').click()">
          üìÑ Load XML File
        </button>
        <span class="tooltiptext">Select a single XML file from your computer. It will automatically convert to JSON within 1 second!</span>
      </div>
      <input type="file" id="singleFileInput" accept=".xml" style="display: none;">

      <div class="tooltip">
        <button class="btn btn-primary" onclick="document.getElementById('batchFileInput').click()">
          üìÅ Load Multiple Files
        </button>
        <span class="tooltiptext">Select multiple XML files at once (Ctrl+Click). Each file gets its own tab and converts automatically.</span>
      </div>
      <input type="file" id="batchFileInput" accept=".xml" multiple style="display: none;">

      <div class="tooltip">
        <button class="btn btn-success" id="convertBtn" disabled onclick="smartConvert()">
          <span id="convertBtnText">‚ö° Convert</span>
        </button>
        <span class="tooltiptext" id="convertTooltip">Manually re-run conversion. Usually not needed since conversion is automatic!</span>
      </div>

      <div class="tooltip">
        <button class="btn btn-secondary" id="downloadBtn" disabled onclick="smartDownload()">
          <span id="downloadBtnText">‚¨áÔ∏è Download JSON</span>
        </button>
        <span class="tooltiptext" id="downloadTooltip">Download the converted JSON file. Multiple files create a ZIP!</span>
      </div>

      <div class="tooltip">
        <button class="btn btn-secondary" id="clearBtn" onclick="clearAll()">
          üóëÔ∏è Clear
        </button>
        <span class="tooltiptext">Remove all files and start fresh. Clears your entire workspace.</span>
      </div>

      <a href="xml-to-json-help.html" target="_blank" class="btn btn-secondary" style="text-decoration: none;" title="Open comprehensive help guide with tutorials, troubleshooting, and examples">
        ‚ùì Help
      </a>

      <div style="margin-left: auto;">
        <span style="font-size: 0.85rem; color: #6b7280; margin-right: 10px;">Editor Theme:</span>
        <div class="theme-toggle">
          <button class="theme-btn active" id="lightThemeBtn" onclick="setTheme('light')">
            ‚òÄÔ∏è Light
          </button>
          <button class="theme-btn" id="darkThemeBtn" onclick="setTheme('dark')">
            üåô Dark
          </button>
        </div>
      </div>
    </div>

    <div class="content">
      <div id="alertContainer"></div>
      
      <div id="statsContainer"></div>

      <div class="converter-layout">
        <div class="editor-panel">
          <div class="panel-header">
            <span>üìù XML Input</span>
          </div>
          <div class="tabs-container" id="xmlTabs"></div>
          <div class="panel-content" id="xmlPanels"></div>
        </div>

        <div class="convert-arrow">‚Üí</div>

        <div class="editor-panel">
          <div class="panel-header">
            <span>‚ú® JSON Output</span>
            <div style="display: flex; gap: 8px;">
              <button class="btn btn-secondary" onclick="editInJsonEditor()" id="editJsonBtn" disabled style="padding: 5px 10px; font-size: 0.85rem;">
                ‚úèÔ∏è Edit in JSON Editor
              </button>
              <button class="btn btn-secondary" onclick="copyCurrentJSON()" style="padding: 5px 10px; font-size: 0.85rem;">
                üìã Copy
              </button>
            </div>
          </div>
          <div class="tabs-container" id="jsonTabs"></div>
          <div class="panel-content" id="jsonPanels"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    let files = []; // Array of {id, name, xml, json}
    let activeFileId = null;
    let fileIdCounter = 0;

    const singleFileInput = document.getElementById('singleFileInput');
    const batchFileInput = document.getElementById('batchFileInput');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const alertContainer = document.getElementById('alertContainer');
    const statsContainer = document.getElementById('statsContainer');

    // Initialize with one empty tab
    addFile('Untitled', '', null);

    // Single file load
    singleFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const xmlContent = e.target.result;
        const filename = file.name.replace('.xml', '');
        
        // Validate it's actually XML
        if (!xmlContent.trim().startsWith('<')) {
          showAlert('error', `‚úó "${file.name}" doesn't appear to be a valid XML file.<br><br><strong>Tip:</strong> XML files must start with a &lt; character. Check that your file is actually XML and not a different format.`);
          return;
        }
        
        // Validate XML is well-formed
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
        const parserError = xmlDoc.querySelector('parsererror');
        
        if (parserError) {
          const errorText = parserError.textContent;
          const lineMatch = errorText.match(/line (\d+)/);
          const lineNum = lineMatch ? lineMatch[1] : 'unknown';
          
          showAlert('error', `‚úó "${file.name}" contains invalid XML (Line ${lineNum})<br><br><strong>Error:</strong> ${errorText.substring(0, 150)}...<br><br><strong>Fix:</strong> Correct the XML syntax errors before loading. Use an XML validator to identify all issues.`);
          return;
        }
        
        // Remove empty Untitled tabs before adding new file
        files = files.filter(f => f.xml && f.xml.trim());
        
        addFile(filename, xmlContent, null);
        
        // Auto-convert immediately
        autoConvertFile(activeFileId);
        
        showAlert('success', `‚úì Loaded and converted: ${file.name}`);
      };
      
      reader.onerror = () => {
        showAlert('error', `‚úó Failed to read "${file.name}"<br><br><strong>Possible causes:</strong><br>‚Ä¢ File is corrupted or locked<br>‚Ä¢ File is too large<br>‚Ä¢ Insufficient permissions<br><br><strong>Try:</strong> Re-saving the file and trying again.`);
      };
      
      reader.readAsText(file);
      singleFileInput.value = ''; // Reset for re-upload
    });

    // Batch files load
    batchFileInput.addEventListener('change', (e) => {
      const fileList = Array.from(e.target.files);
      if (fileList.length === 0) return;

      // Clear ALL existing files (including empty ones)
      files = [];
      renderTabs();

      let loaded = 0;
      let errors = 0;
      const errorList = [];
      
      fileList.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const xmlContent = e.target.result;
          const filename = file.name.replace('.xml', '');
          
          // Validate XML format
          if (!xmlContent.trim().startsWith('<')) {
            errors++;
            errorList.push({
              name: file.name,
              error: 'Not a valid XML file (must start with &lt;)'
            });
          } else {
            // Validate XML is well-formed
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
            const parserError = xmlDoc.querySelector('parsererror');
            
            if (parserError) {
              errors++;
              const errorText = parserError.textContent;
              const lineMatch = errorText.match(/line (\d+)/);
              const lineNum = lineMatch ? `Line ${lineMatch[1]}` : 'Unknown line';
              errorList.push({
                name: file.name,
                error: `${lineNum}: ${errorText.substring(0, 100)}`
              });
            } else {
              // Valid XML - add it
              addFile(filename, xmlContent, null);
              autoConvertFile(activeFileId);
            }
          }
          
          loaded++;
          if (loaded === fileList.length) {
            if (errors === 0) {
              showAlert('success', `‚úì Loaded and converted all ${fileList.length} files!`);
            } else {
              // Show detailed error list
              const errorHtml = errorList.map(err => 
                `<div style="margin: 10px 0; padding: 10px; background: #fef2f2; border-left: 3px solid #ef4444; border-radius: 4px;">
                  <strong>${err.name}</strong><br>
                  <span style="color: #991b1b; font-size: 0.9rem;">${err.error}</span>
                </div>`
              ).join('');
              
              const successCount = fileList.length - errors;
              showAlert('error', `
                <strong>‚ö†Ô∏è Loaded ${successCount} of ${fileList.length} files</strong><br><br>
                <div style="max-height: 300px; overflow-y: auto;">
                  <strong>${errors} file(s) failed validation:</strong><br>
                  ${errorHtml}
                </div>
                <br><strong>Fix:</strong> Correct the XML syntax errors in the failed files and try again.
              `);
            }
          }
        };
        
        reader.onerror = () => {
          errors++;
          loaded++;
          errorList.push({
            name: file.name,
            error: 'Failed to read file (corrupted or locked)'
          });
          
          if (loaded === fileList.length) {
            const successCount = fileList.length - errors;
            const errorHtml = errorList.map(err => 
              `<div style="margin: 10px 0; padding: 10px; background: #fef2f2; border-left: 3px solid #ef4444; border-radius: 4px;">
                <strong>${err.name}</strong><br>
                <span style="color: #991b1b; font-size: 0.9rem;">${err.error}</span>
              </div>`
            ).join('');
            
            showAlert('error', `
              <strong>‚ö†Ô∏è Loaded ${successCount} of ${fileList.length} files</strong><br><br>
              <div style="max-height: 300px; overflow-y: auto;">
                <strong>${errors} file(s) failed:</strong><br>
                ${errorHtml}
              </div>
            `);
          }
        };
        
        reader.readAsText(file);
      });
      
      batchFileInput.value = ''; // Reset
    });

    function addFile(name, xml, json) {
      const id = fileIdCounter++;
      files.push({ 
        id, 
        name, 
        xml, 
        json, 
        originalXml: xml, // Store very first XML version
        originalJson: json, // Store very first version
        changedXmlLines: new Set(), // Track XML line changes
        changedLines: new Set() // Track all lines that have ever changed
      });
      activeFileId = id;
      renderTabs();
      updateStats();
    }

    function removeFile(id) {
      if (files.length === 1) {
        showAlert('error', '‚úó Cannot close the last file');
        return;
      }
      
      const index = files.findIndex(f => f.id === id);
      files.splice(index, 1);
      
      if (activeFileId === id) {
        activeFileId = files[0].id;
      }
      
      renderTabs();
      updateStats();
    }

    function setActiveFile(id) {
      activeFileId = id;
      renderTabs();
      updateStats();
    }

    function renderTabs() {
      const xmlTabsContainer = document.getElementById('xmlTabs');
      const jsonTabsContainer = document.getElementById('jsonTabs');
      const xmlPanelsContainer = document.getElementById('xmlPanels');
      const jsonPanelsContainer = document.getElementById('jsonPanels');

      // Render XML tabs
      xmlTabsContainer.innerHTML = files.map(file => `
        <button class="tab ${file.id === activeFileId ? 'active' : ''}" onclick="setActiveFile(${file.id})">
          <span>${file.name}</span>
          <span class="tab-close" onclick="event.stopPropagation(); removeFile(${file.id})">√ó</span>
        </button>
      `).join('');

      // Render JSON tabs
      jsonTabsContainer.innerHTML = files.map(file => `
        <button class="tab ${file.id === activeFileId ? 'active' : ''}" onclick="setActiveFile(${file.id})">
          <span>${file.name}</span>
          ${file.json ? '<span style="color: #10b981; margin-left: 5px;">‚úì</span>' : ''}
          ${file.error ? '<span style="color: #ef4444; margin-left: 5px;">‚úó</span>' : ''}
        </button>
      `).join('');

      // Get current theme
      const isDark = localStorage.getItem('editorTheme') === 'dark';
      const themeClass = isDark ? 'dark-theme' : '';

      // Render XML panels
      xmlPanelsContainer.innerHTML = files.map(file => `
        <div class="tab-content ${file.id === activeFileId ? 'active' : ''}" data-file-id="${file.id}">
          <textarea class="${themeClass}" 
                    oninput="updateFileXML(${file.id}, this.value)"
                    placeholder="Paste XML here or load a file...">${file.xml || ''}</textarea>
        </div>
      `).join('');

      // Render JSON panels with cumulative change highlighting
      jsonPanelsContainer.innerHTML = files.map(file => {
        let jsonContent = '';
        
        if (file.json) {
          const lines = file.json.split('\n');
          
          // Ensure changedLines exists (safety check for batch loads)
          if (!file.changedLines) {
            file.changedLines = new Set();
          }
          
          // Highlight all lines that have changed from original
          jsonContent = lines.map((line, index) => {
            const isChanged = file.changedLines.has(index);
            const escapedLine = escapeHtml(line);
            return isChanged ? 
              `<div style="background: #d1fae5; border-left: 3px solid #10b981; margin: 0 -20px; padding: 0 20px;">${escapedLine}</div>` : 
              `<div>${escapedLine}</div>`;
          }).join('');
        }
        
        const isDark = localStorage.getItem('editorTheme') === 'dark';
        const bgColor = isDark ? '#1f2937' : '#ffffff';
        const textColor = isDark ? '#10b981' : '#1f2937';
        const hasChanges = file.changedLines && file.changedLines.size > 0;
        
        return `
          <div class="tab-content ${file.id === activeFileId ? 'active' : ''}" data-file-id="${file.id}">
            ${file.error ? 
              `<div style="padding: 20px; color: #ef4444; background: #fee2e2; border: 2px solid #ef4444; margin: 20px; border-radius: 8px;">
                <strong>‚ö†Ô∏è Conversion Error:</strong><br>${file.error}
              </div>` : 
              ''}
            ${hasChanges ? 
              `<div style="padding: 10px 20px; background: #d1fae5; color: #065f46; border-bottom: 2px solid #10b981; font-weight: 600; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center;">
                <span title="These lines changed from the original version. Highlights persist until you download or click Clear Highlights.">‚ú® Changes Made (${file.changedLines.size})</span>
                <button onclick="clearHighlights(${file.id})" style="padding: 5px 10px; background: white; border: 1px solid #10b981; border-radius: 4px; color: #065f46; font-size: 0.85rem; cursor: pointer; font-weight: 600;" title="Reset baseline to current version. Future edits will highlight from this point.">
                  Clear Highlights
                </button>
              </div>` : 
              ''}
            <div style="flex: 1; overflow-y: auto; overflow-x: hidden; background: ${bgColor}; color: ${textColor}; font-family: 'Courier New', monospace; font-size: 0.95rem; padding: 20px; line-height: 1.5; word-wrap: break-word;">
              ${jsonContent || '<div style="color: #9ca3af;">Converted JSON will appear here...</div>'}
            </div>
          </div>
        `;
      }).join('');

      // Enable/disable buttons and update text
      const activeFile = files.find(f => f.id === activeFileId);
      convertBtn.disabled = !activeFile || !activeFile.xml;
      downloadBtn.disabled = !activeFile || !activeFile.json;
      
      const editJsonBtn = document.getElementById('editJsonBtn');
      if (editJsonBtn) {
        editJsonBtn.disabled = !activeFile || !activeFile.json;
      }
      
      updateConvertButton();
      
      // Auto-scroll to last changed line if there are changes
      if (activeFile && activeFile.changedLines && activeFile.changedLines.size > 0) {
        scrollToLastChange(activeFile);
      }
    }

    function scrollToLastChange(file) {
      // Small delay to ensure DOM is rendered
      setTimeout(() => {
        // Get the actual scrollable container (the div with overflow)
        const scrollContainer = document.querySelector(`#jsonPanels .tab-content.active > div:last-child`);
        if (!scrollContainer) return;
        
        // Find the last changed line number
        const changedLinesArray = Array.from(file.changedLines).sort((a, b) => b - a);
        const lastChangedLine = changedLinesArray[0];
        
        if (lastChangedLine === undefined) return;
        
        // Get all line divs inside the scrollable container
        const lineDivs = scrollContainer.querySelectorAll('div');
        if (lastChangedLine < lineDivs.length) {
          const targetLine = lineDivs[lastChangedLine];
          
          // Get the height of the scrollable area (the text box itself)
          const scrollableHeight = scrollContainer.clientHeight;
          
          // Get current scroll position
          const currentScroll = scrollContainer.scrollTop;
          
          // Get the line's position within the scrollable container
          const lineTop = targetLine.offsetTop - scrollContainer.offsetTop;
          
          // Calculate scroll to put the line in the center of the text box
          const scrollPosition = lineTop - (scrollableHeight / 2);
          
          // Smooth scroll to position
          scrollContainer.scrollTo({
            top: Math.max(0, scrollPosition),
            behavior: 'smooth'
          });
        }
      }, 150);
    }

    function highlightXMLErrorLine(fileId, lineNumber) {
      // Small delay to ensure DOM is rendered
      setTimeout(() => {
        const textarea = document.querySelector(`#xmlPanels .tab-content[data-file-id="${fileId}"].active textarea`);
        if (!textarea) return;
        
        const lines = textarea.value.split('\n');
        const lineIndex = lineNumber - 1; // Convert to 0-based index
        
        if (lineIndex < 0 || lineIndex >= lines.length) return;
        
        // Calculate character position for the error line
        let charPosition = 0;
        for (let i = 0; i < lineIndex; i++) {
          charPosition += lines[i].length + 1; // +1 for newline
        }
        
        const lineLength = lines[lineIndex].length;
        
        // Select the entire error line
        textarea.focus();
        textarea.setSelectionRange(charPosition, charPosition + lineLength);
        
        // Calculate scroll to center the error line in the textarea viewport
        const textareaHeight = textarea.clientHeight;
        const totalLines = lines.length;
        const scrollHeight = textarea.scrollHeight;
        
        // Calculate approximate position of the error line
        const linePositionRatio = lineIndex / totalLines;
        const targetScrollTop = (scrollHeight * linePositionRatio) - (textareaHeight / 2);
        
        // Scroll to center the line
        textarea.scrollTop = Math.max(0, targetScrollTop);
        
      }, 200);
    }

    function editInJsonEditor() {
      const activeFile = files.find(f => f.id === activeFileId);
      if (!activeFile || !activeFile.json) {
        showAlert('error', '‚úó No JSON available to edit.<br><br><strong>Why:</strong> The XML hasn\'t been converted yet or conversion failed.<br><strong>Fix:</strong><br>1. Make sure your XML loaded (check for green ‚úì on JSON tab)<br>2. Wait 1 second for auto-conversion<br>3. If you see red ‚úó, check the error message<br>4. Click Help button for troubleshooting');
        return;
      }

      // Store the JSON in localStorage for the editor to pick up
      const editorData = {
        filename: activeFile.name + '.json',
        content: activeFile.json,
        sourceConverter: true,
        converterId: activeFile.id,
        timestamp: Date.now()
      };
      
      localStorage.setItem('jsonEditorData', JSON.stringify(editorData));
      
      // Open Simple JSON Editor in new tab with slight delay
      setTimeout(() => {
        const editorWindow = window.open('Simple-JSON-Editor.html', '_blank');
        if (!editorWindow) {
          showAlert('error', '‚úó Popup blocked!<br><br><strong>Fix:</strong> Allow popups for this page in your browser, then try again.');
        } else {
          showAlert('success', '‚úì Opening JSON Editor in new tab. Make your edits there and click Save to sync back!');
        }
      }, 200);
    }

    // Listen for changes from JSON Editor
    window.addEventListener('storage', (e) => {
      if (e.key === 'jsonEditorSaved') {
        const savedData = JSON.parse(e.newValue);
        
        // Update the file with edited JSON
        const file = files.find(f => f.id === savedData.converterId);
        if (file) {
          file.json = savedData.content;
          renderTabs();
          updateStats();
          showAlert('success', '‚úì JSON updated from editor!');
        }
        
        // Clear the flag
        localStorage.removeItem('jsonEditorSaved');
      }
    });

    function updateConvertButton() {
      const convertBtnText = document.getElementById('convertBtnText');
      const convertTooltip = document.getElementById('convertTooltip');
      const downloadBtnText = document.getElementById('downloadBtnText');
      const downloadTooltip = document.getElementById('downloadTooltip');
      
      const filesWithXml = files.filter(f => f.xml && f.xml.trim()).length;
      const filesWithJson = files.filter(f => f.json).length;
      
      // Update Convert button (now for re-converting)
      if (filesWithXml <= 1) {
        convertBtnText.textContent = 'üîÑ Re-Convert';
        convertTooltip.textContent = 'Re-convert current file (if you made changes)';
      } else {
        convertBtnText.textContent = `üîÑ Re-Convert All (${filesWithXml})`;
        convertTooltip.textContent = `Re-convert all ${filesWithXml} files`;
      }
      
      // Update Download button
      if (filesWithJson <= 1) {
        downloadBtnText.textContent = '‚¨áÔ∏è Download JSON';
        downloadTooltip.textContent = 'Download the converted JSON file';
      } else {
        downloadBtnText.textContent = `‚¨áÔ∏è Download All (${filesWithJson})`;
        downloadTooltip.textContent = `Download all ${filesWithJson} files as ZIP`;
      }
    }

    function smartConvert() {
      const filesWithXml = files.filter(f => f.xml && f.xml.trim()).length;
      
      if (filesWithXml <= 1) {
        // Single file mode
        convertSingle();
      } else {
        // Batch mode
        convertBatch();
      }
    }

    function autoConvertFile(fileId) {
      const file = files.find(f => f.id === fileId);
      if (!file || !file.xml) return;

      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(file.xml, "text/xml");

        const parserError = xmlDoc.querySelector('parsererror');
        if (parserError) {
          const errorText = parserError.textContent;
          let helpfulError = 'Invalid XML syntax';
          let errorLine = null;
          
          // Extract line number from error message
          const lineMatch = errorText.match(/line (\d+)/);
          if (lineMatch) {
            errorLine = parseInt(lineMatch[1]);
          }
          
          // Provide specific help based on error type
          if (errorText.includes('EntityRef: expecting')) {
            helpfulError += errorLine ? ` (Line ${errorLine})` : '';
            helpfulError += '<br><br><strong>Problem:</strong> Unescaped special character (usually &amp;)<br><strong>Fix:</strong> Replace special characters with:<br>‚Ä¢ &amp; with &amp;amp;<br>‚Ä¢ &lt; with &amp;lt;<br>‚Ä¢ &gt; with &amp;gt;<br>‚Ä¢ " with &amp;quot;<br>‚Ä¢ \' with &amp;apos;';
          } else if (errorText.includes('mismatched tag')) {
            helpfulError += errorLine ? ` (Line ${errorLine})` : '';
            helpfulError += '<br><br><strong>Problem:</strong> Opening and closing tags don\'t match<br><strong>Example:</strong> &lt;item&gt; ... &lt;/items&gt;<br><strong>Fix:</strong> Make sure every opening tag has a matching closing tag with the exact same name.';
          } else if (errorText.includes('unclosed')) {
            helpfulError += errorLine ? ` (Line ${errorLine})` : '';
            helpfulError += '<br><br><strong>Problem:</strong> A tag wasn\'t closed properly<br><strong>Fix:</strong> Make sure all tags have closing tags: &lt;tag&gt;...&lt;/tag&gt;';
          } else if (errorText.includes('attribute')) {
            helpfulError += errorLine ? ` (Line ${errorLine})` : '';
            helpfulError += '<br><br><strong>Problem:</strong> Attribute format error<br><strong>Fix:</strong> Attributes should be: name="value" with quotes around the value.';
          } else {
            // Show the actual error for other cases
            if (errorLine) {
              helpfulError += ` (Line ${errorLine})<br><br><strong>Details:</strong> ${errorText.substring(0, 200)}`;
            }
            helpfulError += '<br><br><strong>Tip:</strong> Use an online XML validator to find the specific error location.';
          }
          
          // Highlight the error line in XML input
          if (errorLine) {
            highlightXMLErrorLine(file.id, errorLine);
          }
          
          file.json = null;
          file.error = helpfulError;
          renderTabs();
          updateStats();
          return;
        }

        const json = xmlToJson(xmlDoc);
        const jsonString = JSON.stringify(json, null, 2);
        
        // Validate JSON output
        try {
          JSON.parse(jsonString); // Test if valid
          
          // Track cumulative changes - compare to original
          if (file.originalJson === null) {
            // First conversion - this becomes the baseline
            file.originalJson = jsonString;
            file.changedLines = new Set();
          } else if (file.originalJson !== jsonString) {
            // Compare current to original to find ALL cumulative changes
            const originalLines = file.originalJson.split('\n');
            const currentLines = jsonString.split('\n');
            
            currentLines.forEach((line, index) => {
              if (originalLines[index] !== line) {
                file.changedLines.add(index);
              }
            });
          }
          
          file.json = jsonString;
          file.error = null;
          
        } catch (jsonError) {
          file.json = null;
          file.error = 'JSON formatting error<br><br><strong>This is rare!</strong> Your XML has unusual characters that caused invalid JSON output.<br><strong>Try:</strong> Check for special characters in your XML and ensure they\'re properly escaped.';
          console.error('JSON validation failed:', jsonError);
        }
        
        renderTabs();
        updateStats();
      } catch (error) {
        console.error('Auto-convert failed for ' + file.name + ':', error.message);
        file.json = null;
        file.error = 'Conversion error: ' + error.message + '<br><br><strong>Try:</strong> Click the Help button for troubleshooting tips.';
        renderTabs();
        updateStats();
      }
    }

    function smartDownload() {
      const filesWithJson = files.filter(f => f.json).length;
      
      if (filesWithJson <= 1) {
        // Single file download
        downloadJSON();
      } else {
        // Batch download as ZIP
        downloadAllJSON();
      }
      
      // Clear highlights after download
      const activeFile = files.find(f => f.id === activeFileId);
      if (activeFile && filesWithJson <= 1) {
        // For single file, clear highlights immediately
        setTimeout(() => {
          clearHighlights(activeFileId);
          showAlert('success', '‚úì File downloaded. Change highlights cleared.');
        }, 500);
      } else if (filesWithJson > 1) {
        // For multiple files, clear all highlights
        setTimeout(() => {
          files.forEach(f => {
            if (f.json) {
              f.changedLines = new Set();
              f.originalJson = f.json; // Reset baseline
            }
          });
          renderTabs();
          showAlert('success', '‚úì ZIP downloaded. All change highlights cleared.');
        }, 500);
      }
    }

    function clearHighlights(fileId) {
      const file = files.find(f => f.id === fileId);
      if (file) {
        file.changedLines = new Set(); // Clear all tracked changes
        file.originalJson = file.json; // Reset baseline to current version
        renderTabs();
        showAlert('success', '‚úì Change highlights cleared. Current version is now the baseline.');
      }
    }

    function updateFileXML(id, xml) {
      const file = files.find(f => f.id === id);
      if (file) {
        file.xml = xml;
        
        // Auto-convert after a short delay (debounce typing)
        clearTimeout(file.convertTimeout);
        file.convertTimeout = setTimeout(() => {
          autoConvertFile(id);
        }, 1000); // Wait 1 second after user stops typing
      }
    }

    function convertSingle() {
      const activeFile = files.find(f => f.id === activeFileId);
      if (!activeFile || !activeFile.xml) return;

      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(activeFile.xml, "text/xml");

        const parserError = xmlDoc.querySelector('parsererror');
        if (parserError) {
          throw new Error('Invalid XML: ' + parserError.textContent);
        }

        const json = xmlToJson(xmlDoc);
        const jsonString = JSON.stringify(json, null, 2);
        
        activeFile.json = jsonString;
        renderTabs();
        updateStats();
        
        showAlert('success', '‚úì Conversion successful!');
      } catch (error) {
        showAlert('error', `‚úó Conversion failed: ${error.message}<br><br><strong>Tip:</strong> Make sure your XML is well-formed.`);
      }
    }

    function convertBatch() {
      let successCount = 0;
      let failCount = 0;

      files.forEach(file => {
        if (!file.xml) return;

        try {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(file.xml, "text/xml");

          const parserError = xmlDoc.querySelector('parsererror');
          if (parserError) {
            throw new Error('Invalid XML');
          }

          const json = xmlToJson(xmlDoc);
          const jsonString = JSON.stringify(json, null, 2);
          
          // Set original if not set
          if (file.originalJson === null) {
            file.originalJson = jsonString;
            file.changedLines = new Set();
          } else if (file.originalJson !== jsonString) {
            // Track changes
            const originalLines = file.originalJson.split('\n');
            const currentLines = jsonString.split('\n');
            
            currentLines.forEach((line, index) => {
              if (originalLines[index] !== line) {
                file.changedLines.add(index);
              }
            });
          }
          
          file.json = jsonString;
          successCount++;
        } catch (error) {
          failCount++;
        }
      });

      renderTabs();
      updateStats();

      if (failCount === 0) {
        showAlert('success', `‚úì Successfully converted all ${successCount} files!`);
      } else {
        showAlert('error', `‚ö†Ô∏è Converted ${successCount} files, ${failCount} failed.`);
      }
    }

    function xmlToJson(xml) {
      let obj = {};

      if (xml.nodeType === 1) {
        if (xml.attributes.length > 0) {
          obj["@attributes"] = {};
          for (let j = 0; j < xml.attributes.length; j++) {
            const attribute = xml.attributes.item(j);
            obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
          }
        }
      } else if (xml.nodeType === 3) {
        obj = xml.nodeValue.trim();
      }

      if (xml.hasChildNodes()) {
        for (let i = 0; i < xml.childNodes.length; i++) {
          const item = xml.childNodes.item(i);
          const nodeName = item.nodeName;
          
          if (nodeName === "#text") {
            const text = item.nodeValue.trim();
            if (text) {
              if (Object.keys(obj).length === 0) {
                return text;
              }
              obj["#text"] = text;
            }
          } else {
            if (typeof obj[nodeName] === "undefined") {
              obj[nodeName] = xmlToJson(item);
            } else {
              if (typeof obj[nodeName].push === "undefined") {
                const old = obj[nodeName];
                obj[nodeName] = [];
                obj[nodeName].push(old);
              }
              obj[nodeName].push(xmlToJson(item));
            }
          }
        }
      }
      
      return obj;
    }

    function downloadJSON() {
      const activeFile = files.find(f => f.id === activeFileId);
      if (!activeFile || !activeFile.json) return;
      
      const blob = new Blob([activeFile.json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = activeFile.name + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showAlert('success', `‚úì Downloaded: ${activeFile.name}.json`);
    }

    async function downloadAllJSON() {
      const zip = new JSZip();
      
      files.forEach(file => {
        if (file.json) {
          zip.file(file.name + '.json', file.json);
        }
      });
      
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'converted-json-files.zip';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showAlert('success', '‚úì Downloaded all files as ZIP!');
    }

    function copyCurrentJSON() {
      const activeFile = files.find(f => f.id === activeFileId);
      if (!activeFile || !activeFile.json) return;

      // Create temporary textarea to copy from
      const textarea = document.createElement('textarea');
      textarea.value = activeFile.json;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      
      showAlert('success', '‚úì Copied to clipboard!');
    }

    function clearAll() {
      files = [];
      fileIdCounter = 0;
      addFile('Untitled', '', null);
      
      statsContainer.innerHTML = '';
      showAlert('info', 'Cleared all files');
    }

    function updateStats() {
      const activeFile = files.find(f => f.id === activeFileId);
      if (!activeFile || !activeFile.xml) {
        statsContainer.innerHTML = '';
        return;
      }

      const xmlSize = activeFile.xml ? (new Blob([activeFile.xml]).size / 1024).toFixed(2) : 0;
      const jsonSize = activeFile.json ? (new Blob([activeFile.json]).size / 1024).toFixed(2) : 0;
      const reduction = xmlSize && jsonSize ? (((xmlSize - jsonSize) / xmlSize) * 100).toFixed(1) : 0;
      
      // Only count files that have XML content
      const realFiles = files.filter(f => f.xml && f.xml.trim());
      const convertedCount = realFiles.filter(f => f.json).length;
      const totalCount = realFiles.length;

      statsContainer.innerHTML = `
        <div class="stats-bar">
          <div class="stat-item">
            <div class="label">Files</div>
            <div class="value">${convertedCount}/${totalCount}</div>
          </div>
          <div class="stat-item">
            <div class="label">XML Size</div>
            <div class="value">${xmlSize} KB</div>
          </div>
          <div class="stat-item">
            <div class="label">JSON Size</div>
            <div class="value">${jsonSize} KB</div>
          </div>
          <div class="stat-item">
            <div class="label">Size Change</div>
            <div class="value" style="color: ${reduction > 0 ? '#10b981' : '#ef4444'}">
              ${reduction > 0 ? '-' : '+'}${Math.abs(reduction)}%
            </div>
          </div>
          <div class="stat-item">
            <div class="label">Status</div>
            <div class="value" style="color: ${activeFile.json ? '#10b981' : '#f59e0b'}; font-size: 1.2rem;">
              ${activeFile.json ? '‚úì Converted' : '‚è≥ Ready'}
            </div>
          </div>
        </div>
      `;
    }

    function showAlert(type, message) {
      const alertClass = type === 'success' ? 'alert-success' : 
                        type === 'error' ? 'alert-error' : 'alert-info';
      alertContainer.innerHTML = `<div class="alert ${alertClass}">${message}</div>`;
      setTimeout(() => { alertContainer.innerHTML = ''; }, 5000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function setTheme(theme) {
      const allTextareas = document.querySelectorAll('textarea');
      const lightBtn = document.getElementById('lightThemeBtn');
      const darkBtn = document.getElementById('darkThemeBtn');

      if (theme === 'dark') {
        allTextareas.forEach(textarea => textarea.classList.add('dark-theme'));
        lightBtn.classList.remove('active');
        darkBtn.classList.add('active');
      } else {
        allTextareas.forEach(textarea => textarea.classList.remove('dark-theme'));
        lightBtn.classList.add('active');
        darkBtn.classList.remove('active');
      }

      // Save preference
      localStorage.setItem('editorTheme', theme);
      
      // Re-render JSON panels to apply theme to divs
      if (files.length > 0) {
        renderTabs();
      }
    }

    // Load saved theme on startup
    window.addEventListener('DOMContentLoaded', () => {
      const savedTheme = localStorage.getItem('editorTheme') || 'light';
      setTheme(savedTheme);
    });
  </script>
</body>
</html>
